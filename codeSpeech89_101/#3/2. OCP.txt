#OCP

(1)
솔리드원칙중 OCP이 있다
좋은코드인지 나쁜코드인지 알 수 있는 기준은 OCP의 준수상태를 통해 알 수 있다

코드가 확정적이여서 더 이상 변화가 없을 것 같다면 OCP를 쓰지않아도 된다
하지만, 변하지 않는 프로그램은 없고 프로그래밍 역사상 유일한 원칙은 프로그램은 변한다

(2)
OCP - 수정에는 닫혀있고, 확장에는 열려있다
OCP는 다양한 레벨에서 일어난다, 
모듈, 코드레벨, 패키지

오늘의 OCP는 코드레벨의 OCP이다.
코드수정에는 닫혀있고, 케이스(switch의 병렬조건)확장에는 열려있다
>> switch문을 쓰지 않는다
>> 오늘은 if-else였으나 내일은 3개의 케이스로 바뀌었다

(3)
왜 switch를 제거하면 OCP가 되는가??

수정시 함수 안 switch소스를 수정해야 되기 때문이다.
만약에 switch를 안 쓰면 객체 위에 추가만 하면된다
코드를 건드리는 순간 다시 그 코드가 명확하게 작동되는지 확인해야 된다

(4)
가장 쉽게 OCP를 달성하는 방법은 라우터와 라우팅 테이블을 만드는것이다
switch를 만나면 라우터와 라우팅 테이블을 만든다

(5)
우리는 문을 식으로 바꾸었다 상태 하나 하나를 값으로 바꾸어서 처리했다
OCP는 일반적으로 커맨드패턴을 달성한다

(6)
커맨드패턴은 제어문을 식으로 바꾸는 패턴이다
if하나에 해당되는 라우팅 테이블과 라우터를 만들 수 있다
라우터의 조건은 mandatory이여야 한다


#정리
1. 모든 케이스는 반드시 라우터와 라우터테이블로 대체할 수 있다
>>> 라우터는 제어를 갖게된다, 그러면 제어가 옮겨졌을 뿐이지 사라진게 아니다 변화율이 라우팅테이블보다 드문드문 발생한다.
>>> 이것을 Invasion Of Control 제어역전이라고 부른다 혹은 제어센터라고 부른다
>>> 제어센터는 라우터이다
>>> 제어센터는 OCP를 달성하기 위해서도 필요하지만
>>> 사실상 if를 제거할 수 없다 왜냐하면 if는 도메인 그 자체이기 때문이다
>>> 제어를 중복하게 등장하지 않게 하는것이 우리의 목표이다
>>> if를 여러군데에서 등장하지 않게하고 그 도메인 지식을 빌려올때는 반드시 특정함수를 호출해서
	위임된 제어를 사용하게하는것이 목표이다
>>> 제어역전: 코드가 제어에 직접적으로 관여하지 않고 제어를 한 군데에 몰아넣는것이다
>>> 반복되는 제어를 제거하기 위해서 만들었다

2. 라우터는 반드시 mandatory여야한다.

왜 힘들게 if나, switch로 처리하지 않고 라우터와 라우팅테이블을 만드는 이유는 OCP때문이다

미래의 내가 이 코드를 확장하는것이 뻔하기 때문이다

(1)
코드를 분리하는 원칙: 변화율이다
변화율은 다른말로 역할모델이라고 부른다
역할모델: 어떻게 코드의 역할을 나눌 것인가?
>>> 그 코드는 어떤 이유로 바뀔것인가, 유지보수하는 요령
>>> 라우팅테이블은 라우터를 안 고칠때만 유지될 수 있다
>>> 트랜잭션: 라우터의 로직에 맞춰 라우터 테이블이 존재하므로 라우터를 수정하면 테이블을 반드시 다 검토해야한다


(2)
정당한 if는 절대로 사라지지 않는다
if의 단계별 구성요소를 분석해서, 변화율에 따라 OCP를 준수할 수 있는 라우터와 라우팅테이블로 번역한다,
왜? 유지보수가 변화율에 따라 OCP준수 해서 관리성이 좋아짐

코드를 작성할때 설계 또는 디자인 이란?
유지보수 기능 추가 등에 유리하도록(변화율이 동일한 코드끼리 묶여서 OCP를 이루도록) 코드를(함수, 클래스 등의 구조물을 이용해서) ---재배치 하는것
