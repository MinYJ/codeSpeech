#1 FLOW CONTROL
FLOW: 명령이 실행되는 흐름(적재된 순서대로 위->아래)

이 흐름에 관여할 수 있다
제어명령중에 명령의 위치를 바꿔서 이동시켜주는 명령이 내장되어 있다

현대적인 CPU에는 분기를 할때, 특정 메모리의 값을 이용해서 분기하는 지원을 아예 하는 연산이 들어있다
레지스터: 메모리에 있는 값이 CPU에 들어오게 되서 임시적으로 사용되는 상태공간

레지스터의 값에 따라 명령을 분기하는 분기제어가 따로 있다
분기에 따른 결과에따라서 어떤 명령을 실행할지가 결졍된다
그 명령중에는 다른 명령의 위치로 이동시켜주는 명령을 지정할 수 있다


jump를 의도된 위치로 제어하는것을 flow control이라고 한다
70년 if, for를 통해서 흐름을 통제할 수 있다는것을 증명한 이후

마음대로 jump하는것을 금지했으며, for, if, while이 나왔다

(1)
함수는 sub flow라고 부른다
우리는 sub routine을 호출하기전에 서브루틴에게 실행이후 어디로 돌아와야 하는지 돌아올 point도 알려줬다

기본적인 루틴이란? 호출시에 서브루틴의 위치로 갔다가 서브루틴의 플로우가 실행되고 서브루틴의 실행이 끝나면 돌아온다

(2)
서브루틴이 중첩되게되면 중첩된 서브루틴의 복귀를 기다릴때까지 복귀를 할 수 없다
함수 내부에서 함수를 호출하면, 그 함수가 해소되기전까지 앞에있는 함수를 해소할 수 없다
루틴의 메모리구조를 스택이라고 부른다

스택의 특징은 굉장히 속도가 빠르다
메모리구조중 속도가 제일 빠르다 마지막 해제하면 바로 이전으로 갈 수 있기 때문이다


#정리
우리가 작성한것은 컴파일을 통해 명령과 값으로 바뀐다
이 중에 명령의 흐름을 통제하기 위해서 flow control을 사용하게 된다
값을 넣기위해서 식을 사용한다.
값의 위치를 알기 위해서 식별자를 사용한다


(1) const a = 3
const => 명령(문)
a => 식별자
3 => 값(식)

const라는 명령어를 통해 a라는 주소(메모리 위치)에 값 3을 넣어라


(2)
while: recursive상황일때
>> 반복을 진행하면서 얼마나 반복할지 알지 못할때 사용한다
>> 일단 한 번 돌려봐야 그 다음에 할지 말지 알 수 있다
>> 반복하기전에 계획이 명확하지 않은경우

for: iteration상황일때
>> 반복조건을 반복이 들어가기전에 확정지을때 사용한다
>> for문을 보는 순간 우리는 반복되는 상황을 계획하고 안쪽을 반복시킨다
>> 그래서 for문은 내가 반복할 조건을 확실히 알고 있을때 사용한다 
>> 특정한 상황에서 얼만큼 반복될지 이미 알고 있을때 사용된다 
>> 우리가 반복하기전에 계획이 명확한 경우
>> 반복된 조건을 확정한 경우

(3)
내가 for문을 통해서 내가 원하는 로직을 통제할 수 있다
내가 역량이 좋다면 자바스크립트 컴파일러도 for문으로 짤 수 도 있다

"구구단이상을 for문으로 어떻게 짤것인가" 이것이 수업의 목표
json.stringify와 json.parser를 for문으로 짜야한다

(4)
accumulator: 완제품이 아니라 계속 쌓아놓는 적층이다
assemble: 완제품

(5)
재귀함수를 배우는이유: 재귀자체가 중요한것이 아니라 문제를 전체를 통해서 해결하는 것이 아니라
반복적인 프로세스를 통해서 한 부분만 보는 훈련을 한다
왜? 전체를 통제할 능력이 현재 없기 때문이다


(6) 
스택오버플로우는 스크립트엔진의 경우 제약을 걸어놓는다. OS가 자원을 더 확보하기 위해서

(7)
어려운문제에 직면하면 -> 꼬리물기 최적화를 한다 -> 기계적으로 다시 for문으로 바꾼다 
재귀 -> 꼬리물기 최적화 재귀 -> for문으로 기계적으로 번역

(8)
스택오버플로우의 문제: 프로그램이 죽어서 확인해보니 스택오버플로우인데 고칠방법이 없다
왜냐하면 코드가 틀린부분이 없기 때문이다
이 문제를 해결하기 위해서는 처음부터 for로 짜야한다
안 그러면 큰 규모의 생산성 있는 코드를 동작시킬 수 없다