#0
저번 시간에 루프와 제너레이터 배웠다
제너레이터는 동기명령어을 중간에 멈출 수 있는 능력이 있다 (yield를 통해서)
이것을 바탕으로 루프를 추상화시키는 것과 지연실행을 배울것이다

지연실행은 함수의 특권이다
여러분들이 어떤 제어문을 작성했는데 그 문이 즉시 실행되지 않게 할려면 함수에 담아두고 
함수를 호출할 때 까지 지연된다

기본적인 지연실행은 함수호출 지연실행이다
지연실행을 함수호출 지연실행제외하고도 제너레이터를 통해서 지연시킬 수 있다

문이 다 실행되기전에 yield를 통해서 빠져나올 수 있다
기존의 지연실행은 함수형 프로그래밍의 특징이자 특권이었지만
코루틴 지원하는 언어에서는 제어문으로 똑같은 지연실행을 일으킬 수 있다





#1 ABSTRACT LOOP
(1)
LOOP문보다 iterator객체로 바꾸면 loop에 대한 상태값 들을 객체가 가지고 있기에 언제든지 똑같은
루프를 재현할 수 있다 또한 loop문의 역할이 줄어든다

기존의 제어문에서는 많은 역할과 책임을 제어문이 가지고 있었다 
iterator를 통해서 loop의 결정권이 iterator객체에게 넘어가기에 똑같은 loop를 만들 수 있었다

이번시간에는 조금더 복잡한 loop에 대해서 해결을 해보자

(2)
iterable interface는 iterator을 반환한다
iterator는 next()가지고 있다
next()를 호출하면 iterator result interface를 반환한다

(3) 제어문, 구구단이 쉬운이유?
- 루프가 돌면서 루프의 조건이 변하지 않는다
어떤 루프를 돌다보면 루프를 돌고있는 대상자체의 길이가 변하거나 길이가 동적으로 결정되는 경우가 많다

- 확정되어있는 index를 통해서 로직을 구성했다
i와j를 이용하는 다른 객체의 참조도 같이 무언가를 해서 결과가 나온다

(4)
기본적으로 자바스크립트에서 함수는 값이다 그러므로 변수에 할당하는것이 맞다
그래야 호이스팅에 의존하지 않고 어느시점에 함수가 만들어 졌는지 명확하게 코드를 인지할 수 있다

클래스역시 자바스크립트에서는 값이다. 그러므로 변수에 할당가능하다
변수에 할당하게 되면 정확하게 어떤 시점에 클래스르 만들었는지 알 수 있다 

(5)
제어문을 중복정의 하지 않으려면 제어문을 재활용해야한다
문은 사용되고 나면 사라지기 때문에 재활용이 안되는데 어떻게 객체화 할것인가의 문제

(6)
제어문을 직접 사용할 수 없고 구조객체를 이용해 루프실행기를 별도로 구현

(7)
프로그램에서 if문을 제거하는 딱 한 가지 방법은??
우리가 배우는 모든 프로그래밍적 기법은 "if를 어떻게 제거할까"에 대한 연구라고 볼 수 도 있다

if를 그냥 제거할 수 없다
왜? if가 필요해서 태어났기 때문이다
제거가 가능하다면 애초에 필요없는걸 넣었다는 의미이기에 그것이 잘못됬다

if를 제거하는 방법?
if로 나눠지는 경우의 수 만큼의 값을 미리 만들어 두고 바깥쪽에서 그 값을 선택해서 들어오게 하는것이다
그러면 안쪽에 있는 if조건 하나가 사라진다

(8)
3개 만큼의 객체를 만들어 놓고 바깥쪽에서 이 객체를 결정하게 만들면,
값으로 분리할 수 있다

if는 문이기때문에 확정인데 비해 객체는 동적으로 추가할 수 있다
현재 모든걸 결정하지 않고 나중에 유연하게 처리하기 위해서 플러그인 형태를 만들고
 경우의 수 만큼 값을 만든다

(9) 
if문을 값의 형태로 바꿔서 경우의 수 만큼 값을 만들고 그것을 호스팅할 것을 만든다
로직이 복잡하여 별도로 선택가능한 팩토리가 필요했지만 이것을 일반적으로 선택할 수 있게 만든다면
이것은 라우터가 된다

(10) 
웹서버는 사실 URL수만큼 경우의 수를 처리하는데, 지금 URL수가 확정되지도 않고 나중에 더 추가될 수 도 있다.
동적으로 URL추가를 처리할 수 있어야한다.

(11)
v는 제너레이터를 갖고 있다
yield는 내것을 반환하고 중지하고 있다.
yield * v.gene() 다 일드처리하고 그 다음에 문으로 넘어간다

(12)
함수객체를 받지않고 제어문을 추상화하는데 성공했다