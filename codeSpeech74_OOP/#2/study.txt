#1
(1) 스택을 제거 하고 싶으면?
- 더 이상 지역변수와 인자를 기억할 필요가 없도록

(2) 꼬리물기 최적화
- 몇 번을 호출해도 스택이 쌓이지 않는다
- 메모리가 고갈되지 않는다
- 왜 꼬리인가? 제일 마지막함수에 넣어놓기 때문이다

(3) 꼬리물기 최적화 장점
- 스택제거가능
- n단계함수호출이 일어나도 스택이 쌓이지 않기에 메모리 고갈을 방지할 수 있다

#2 예제
(1) const sum = v=>v + (v > 1 ? sum(v - 1) : 0);
위의 재귀함수가 스택을 해제할 수 없는 이유는??
- 연산스택이기 때문이다

(2) return 3 + sum(2)
- + 연산자는 좌항, 우항이 모두 해결되었을 때만 실행할 수 있다
- + 연산자가 스택을 물고있다 
- 이것을 연산스택이라고 부른다
- +연산자가 좌항, 우항이 해결된 이후에

(3)
- 재귀가 끝나지 않고 스택을 못푸는 이유는 +연산자에 있다
- 마지막에 함수호출했음에도 불구하고, 연산식이 있으면 의미없다
- 연산식은 함수호출이다.
- 함수호출은 인자들을 다 해소하기 전까지는 해제되지 않는다.

(4) 현재 문제점
- 메모리를 사용하고 있다
- 연산스택 메모리를 사용하고 있다
- +기가 3은 해석했지만 sum(2)는 해석중이다.
- 이때, 3을 기억하고 있다.
- 좌항에 대한 메모리를 암묵적으로 예약해서 사용하고 있다.
- 레지스터A메모리를 어떻게 옮겨야 tail recursive하게 만들 수 있을까?