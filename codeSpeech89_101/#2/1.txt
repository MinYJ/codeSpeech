(1) 오류와 실패
오류는 일어날 수 있지만 실패하지 않는 경우
내부에 있는 함수나 기능들이 내결함성을 가지는 경우 발생한다

내결함성: 오류발생시 버티는 장치
내결함성을 갖는 함수들은 이해할 수 없는 출력물을 만들어서 
런타임에러 대신에 context에러가 생긴다

즉, 프로그램이 죽지는 않지만 결과가 엉뚱하게 나온다

컴파일에러: 아예 동작을 하지 않는다
런타임에러: 오류케이스시 죽는다
컨텍스트에러: 좀비처럼 살아있다

오류를 감추는 내결함성을 해결할 때는 굉장히 신중하게 생각해야한다

오류가 생겼을때 내결함성을 가지는 것은 좋은것인가??
일반적인 경우에는 무조건 좋지 않다

내결함성을 갖춰야 할 때는 mission critical system 밖에 없다
안쪽 모듈에서 내결함성을 갖추게 되면 context에러에 수렴하게 된다


(2)
디버깅은 하나의 학문이다.
우리가 공부를 하면 이 부분을 해소할 수 있다

오류는 즉시 실패가 아니다. 오류는 내결함성을 거치다가 더 이상 내결함성을 버틸 수 없을 때 실패한다.
우리는 내결함성이 없다면 즉시 실패로 만들 수 있다

프로그램은 내결함성을 갖춰야 하는 경우가 드물기 때문에,
오류가 즉시 가장 빠르게 실패되게 하는 편이 좋다 그래서 고치는데 편하다

내결함성을 가지면 죽지는 않지만(안정성은 좋아지지만) 컨텍스트 오류를 발생시킨다

(3)
내결함성
단점: 컨텍스트 오류 발생시킨다 -> 신뢰성이 떨어짐
장점: 내결함성이 있지만 죽지않는다 -> 안정성이 올라감

컴퓨터 프로그램에서는 신뢰성이 우선순위이다.
죽지는 않지만 신뢰할 수 없는 정보를 주면 그 프로그램을 사용할 수 없다





#1 코드의 역할
이 코드가 수정될때 같은이유로 수정되는 것 끼리 몰려 있나? -> 응집성과 결합도에 대한 문제
유지보수 하기 위해서는 수정하는 이유가 있어야한다

(1)
코드를 분리하거나 함수를 분기하는 이유는 알고리즘이 복잡하거나 길어서가 아니라 유지보수를 위해서
수정하는 이유가 다르다면 다른애들을 분리시킨다 

수정하는 이유가 달라서 분리하는것을 "역할모델"이라고 부른다
역할모델은 수정원인이라고 할 수 있다

(2)
함수의 시그니처: 인자, 함수의 return형태
함수의 시그니처가 일치하면 자바스크립트의 인터페이스가 일치한다라고 한다

(3) 
const로 선언된 람다는 하나의 값이기 때문에 값의 표현끝에는 ;를 붙여야한다





#2 변수의 스코프
변수의 스코프와 라이프사이클에 대해서 생각해보자

라이프사이클: 생명주기 -> 메모리 점유에 대한 이야기
스코프: 변수를 어디에서 읽을 수 있나? -> 권한에 관련된 이야기

라이프 사이클과 스코프는 다르다
우리는 같은 스코프를 유지하면서 라이프 사이클을 길게 혹은 짧게 가져갈 수 있다

연산과 메모리는 서로 교환 할 수 있다
우리가 메모리를 많이 쓰면 연산을 줄일 수 있다
연산을 많이 쓰면 메모리를 줄일 수 있다

만약 라이프 사이클을 길게 가져가는 전략을 사용한다면 메모리의 효율성을 나빠진다
왜냐하면 변수의 생명이 길기때문에 메모리를 계속 점유하기 때문이다
대신에 연산을 줄일 수 있는 장점이 있다


(1)
const는 사후할당이 불가능하기때문에 익명함수를 써야한다

_sum함수는 오직 sum함수만 알고있는 스코프가 자동으로 생성되었다
>> 익명함수가 필요없다 대신에 sum을 const가 아닌 let으로 써야한다

(2)
변수를 사용할때 첫 번째로 고려해야할 것은 스코프이다
이 변수를 누가 알아야 하나??
누구만 알아야 하나??

변수를 사용하기 어려운이유는 스코프를 어떻게 써야하는지
스코프가 무엇인지 모르기때문이다

(3)
arraySum이 살아있는 동안에는 elementSum이 메모리에서 해지되지 않는다
스코프를 똑같이 사용하는데 elementSum의 라이프사이클을 다르게 가져가는 방법도 있다

(4)
메모리와 연산은 상황에따라 프로그래머가 선택한다

(5)
throw는 함수가 아닌 문이여서 식의 일부로 넣을 수 가 없다
throw를 식으로 고치기 위해서 간단한 함수를 만들어야 한다

(6)
재귀함수: 불변값을 사용하고 있기때문에 다음번 함수의 호출로 이전되거나 값을 리턴하는 형식으로 해석이 된다
>>> i라는 변수를 건드리지 않았다
>>> 재귀함수에서는 연산으로 표현
>>> 함수의 호출로 표현
>>> 함수스코프를 지킴
>>> 각 변수를 공유하지 않고 각각을 독립된 형태로 돌리는 루프
>>> 값과 연산으로 표현
>>> _tailRecursiveSum(array, i - 1, array[i] + acc)

제어문: 변수에게 갱신하는 식으로 구성이 된다 
>>> i--를 직접해준다
>>> 변수의 변화로 표현됨
>>> 변수의 값이 변화된 것으로 표현
>>> 변수스코프를 공유하는 재귀
>>> i나 acc라는 상태를 계속 같이 인식하고 공유함
>>> 변수의 변경으로 바뀜(연산의 결과임을 정확하게 알려주도록 기계적으로 번역해야한다 i--대신 i = i - 1)
>>> for (let i = array.length - 1; i > 0; i--)


(7)
let acc = 0;
for (let i = array.length - 1; i > 0; i = i - 1) {
	* acc = array[i] + acc *
}
>>> 기계적 번역의 차이점 루프 도중에 공유하는 메모리의 변수를 계속 변경하는 것으로 재귀함수를 대신하고 있다


재귀함수는 함수의 호출로 새 스택을 만들어서 해결한다
제어문은 그 루프 동안에 공유할 변수를 설정해서 변수의 상태를 갱신하므로써 루프를 이어간다
>>> * *안에서는 함수처럼 돈다

  const f = ()=> acc = array[i] + acc;
  for (; i > 0; i = i - 1) f();
>>> 루프는 결국 몸체가 함수와 똑같다
>>> 재귀함수처럼 몸체를 함수로 호출하는것이 똑같다
>>> for문은 몸체를 함수처럼 호출하는것이 똑같다
>>> 재귀와 다른점은 f함수가 스코프로써 공유하는 변수가 있다 그것이 i와 acc이다
>>> array, i, acc를 스코프로 인식하고 있는 함수를 돌리고 있는것과 마찬가지이다
>>> 함수를 call한것을 대신해서 i를 갱신해서 f()함수를 호출하는것과 똑같다

(8)
재귀와 loop의 차이점은 함수를 연속해서 call한다는것이 아니다
재귀: 공유하는 변수가 없이 함수를 call한다
loop: 공유하는 변수를 스코프로 잡은상태에서 call이 된다, 공유하는 변수가 변하는것으로 재귀함수가 매 번 호출하는것을 대신한다


for문도 마찬가지로 함수를 loop시킨다 for문은 loop할때 인자를 사용하지 않는다
인자가 필요없는이유? 인자가 필요없는 스코프안에 있는 변수를 사용하기 때문이다
즉 for문이라는것은 내부함수가 스코프 덩어리로 되어있는 인자없는 함수를 loop돌리는것으로 볼 수 있다


진짜 재귀함수는 공유하고 있는 스코프 변수는 없고  인자에만 의존하는 함수를 loop돌린다
따라서 for문을 쓸때 어려운부분은 공유변수 상태가 라이프사이클이 길어진다
f함수가 인자를 받지않는 순수함수가 아니다

(9)
i > -1 한 번더 재귀를 호출함으로써 코드중복을 제거했다.





# 정리
(1)
오류와 실패의 관계 - 오류는 중간요소의 내결함성 때문에 실패로 이어지지 않을 수 있다
>>> 오류가 최대한 빨리 실패로 이어지게 작성해라 그 이유는 컨텍스트 에러가 더 무섭기 때문이다

(2)
프로그램에는 신뢰성()과 안정성(컨텍스트 에러가 쉽게 나온다)이 있다

코드의 분리 또는 정리 - 수정되는 원인데 따라 :: 변화율(변화율이 같은 애들끼리 코드를 모은다)
변화율의 원인 -> 수정되는 이유

(3)
자바스크립트 인터페이스: 함수의 이름 인자 반환값의 형식이 일치하는 경우
인터페이스를 일치시키면 컬렉션으로 묶을 수 있다 -> 일종의 일반화
>>> 서로 다른 형태인경우 인터페이스를 일치시켜 일반화를 한다.

(4)
데이터와 데이터를 이용한 알고리즘이 이원화 되면 관리가 불가능 -> 데이터를 소유한 쪽에서 데이터를 사용하는 알고리즘을 제공한다

(5)
꼬리최적화함수를 루프로 고칠때 기계적으로 고친다

(6)
결국 루프는 클로저에만 의존하는 함수를 반복시키고, 재귀함수는 인자에만 의존하는 함수를 반복시킨다.

(7)
반복되는 코드를 제거하기 위해 집착해라

(8)
변수란 스코프와 라이프사이클을 갖는다. 메모리와 연산은 상호 교환할 수 있으며 특히 라이프사이클이 관여함
